<!--方向燈處理，輪胎的轉角差處理，太陽材質尚未貼，大同大學地圖，路燈Steer Light處理，CG_Hw3的HUD搭配
(小地圖，甚至藉由小地圖的滑鼠按鍵射線告訴別人這是甚麼地方，以及速度儀表板，皆可)-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Game Hw2 Demo</title>
    <style>
        #title {
            position: absolute;
            top: 0px;
            width: 100%;
            padding: 10px;
            text-align: center;
            color: #ffff00
        }
        body {
            overflow: hidden
        }
        #speed{
            position: absolute;
            bottom: 0;
            width: 100%;
            padding: 10px;
            text-align: center;
            color: yellow;
        }
    </style>
</head>
<body>
    <div id="title">Game Homework2 Demo</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/96/three.min.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r16/Stats.min.js"></script>
    <script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>
    <script src="https://rawgit.com/jyunming-chen/tutsplus/master/js/text2D.js"></script>
    <script type="x-shader/x-vertex" id="vertexShaderDepth">
        varying vec2 vUV;

        void main() {
            vUV = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>
    <script type="x-shader/x-fragment" id="fragmentShaderDepth">
        uniform sampler2D texture;
        varying vec2 vUV;

        vec4 pack_depth(const in float depth) {
            const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);
            const vec4 bit_mask = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);
            vec4 res = fract(depth * bit_shift);
            res -= res.xxyz * bit_mask;
            return res;
        }

        void main() {
            vec4 pixel = texture2D(texture, vUV);
            if (pixel.a < 0.5) discard;
            gl_FragData[0] = pack_depth(gl_FragCoord.z);
        }
    </script>

    <!-- //---------------------------THREEJS----------------------------- /-->

    <script>
        var camera, scene, renderer, stats, loader, car, lightAngle = 0.0;
        var miniMapBorder, miniMapBorderCamera, miniMapCamera, compass, backAlert;
        var dashboard, dashboardCamera, speedLine;
        var keyboard = new KeyboardState();

        (function () {
            Math.clamp = function (val, min, max) {
                return Math.min(Math.max(val,min),max);
            }
        })();

        class FrontTire{
            constructor(){
                this.angle = 0.0;
                this.body = buildTire();
                this.tire = new THREE.Object3D().add(this.body);
                this.rightTurn = false;
                this.leftTurn = true;
            }
            update(){
                if(keyboard.pressed("left")) {
                    this.angle += 0.07;
                    this.leftTurn = true;
                    this.rightTurn = false;
                }
                else if(keyboard.pressed("right")) {
                    this.angle -= 0.07;
                    this.leftTurn = false;
                    this.rightTurn = true;
                }
                else {
                    this.rightTurn = false;
                    this.leftTurn = false;
                    this.angle = 0.0;
                }

                this.angle = Math.clamp(this.angle, -0.6, 0.6);
                this.body.rotation.y = this.angle;
            }
        }

        class Car{
            constructor(){
                this.speed = 5.0;
                this.angle = 0.0;
                this.pos = new THREE.Vector3(0,10,0);
                this.vel = new THREE.Vector3(this.speed,0,0);
                this.rearTire = new THREE.Object3D();
                this.frontTire = new FrontTire();
                this.body = new THREE.Object3D();
                this.leftRearTire = buildTire();
                this.rightRearTire = buildTire();

                this.frontTire.tire.position.set(12,-5,0);
                this.leftRearTire.position.z = -7.5;
                this.rightRearTire.position.z = 7.5;
                this.rearTire.add(this.leftRearTire,this.rightRearTire);
                this.rearTire.position.set(-12,-5,0);

                var box = new THREE.Mesh(new THREE.BoxGeometry(40,10,15),new THREE.MeshPhongMaterial({color: 0x0000cc}));
                box.castShadow = true;
                this.body.add(this.rearTire,box,this.frontTire.tire);
                this.body.position.copy(this.pos);

                scene.add(this.body);
            }

            update(dt){
                keyboard.update();
                this.frontTire.update();

                if(keyboard.pressed("space"))
                    this.speed = 0.0;
                if(keyboard.pressed("up"))
                    this.speed += 5;
                if(keyboard.pressed("down"))
                    this.speed -= 5;

                this.speed = Math.clamp(this.speed, -175.0, 175.0);
                this.vel = new THREE.Vector3(this.speed,0,0).applyAxisAngle(new THREE.Vector3(0,1,0),this.angle);
                var theta = this.frontTire.angle;

                if(theta !== 0.0) {
                    var RC = this.pos.clone().add(new THREE.Vector3(-12, 0, -24 / Math.tan(theta)).applyAxisAngle(new THREE.Vector3(0, 1, 0), this.angle)); //!
                    var omega = this.speed * Math.tan(theta) / 24;

                    var nextPos = RC.clone().add(this.pos.clone().sub(RC).applyAxisAngle(new THREE.Vector3(0, 1, 0), omega * dt));
                    this.vel = nextPos.clone().sub(this.pos).setLength(this.speed);

                    this.pos.copy(nextPos);
                    this.angle += omega * dt;
                    this.body.rotation.y = this.angle;
                }
                else {
                    this.pos.add(this.vel.clone().multiplyScalar(dt));
                }
                this.body.position.copy(this.pos);

                this.frontTire.body.rotation.z += -this.speed * dt / (2 * Math.PI * 5);
                this.rightRearTire.rotation.z += -this.speed * dt / (2 * Math.PI * 5);
                this.leftRearTire.rotation.z += -this.speed * dt / (2 * Math.PI * 5);

            }
        }

        init();
        animate();

        function buildCompass(){
            // 4 / 5
            var geometry = new THREE.Geometry();
            geometry.vertices.push(
                new THREE.Vector3(0,Math.sqrt(3),0),
                new THREE.Vector3(-1,0,0),
                new THREE.Vector3(1,0,0),
                new THREE.Vector3(0,-Math.sqrt(3),0)
            );

            var face = new THREE.Face3(0,1,2);
            face.materialIndex = 0;
            geometry.faces.push(face);
            face = new THREE.Face3(2,1,3);
            face.materialIndex = 1;
            geometry.faces.push(face);

            geometry.computeBoundingSphere();
            geometry.computeFaceNormals();
            geometry.computeVertexNormals();

            var matArray = [];
            matArray.push(new THREE.MeshBasicMaterial({color: 0xff0000}),new THREE.MeshBasicMaterial({color: 0xffffff}));
            return new THREE.Mesh(geometry,matArray);
        }

        function buildLine() {
            var lineGeo = new THREE.Geometry();
            lineGeo.vertices.push(new THREE.Vector3(0,0,0),new THREE.Vector3(-4.5,0,0));

            return new THREE.Line(lineGeo, new THREE.LineBasicMaterial({color: 0xff0000,depthTest: false}));
        }

        function buildMiniMap() {
            miniMapBorder = new THREE.Scene();
            miniMapBorderCamera = new THREE.OrthographicCamera(-10.1, 10.1, 10.1, -10.1, -50, 50);
            miniMapBorderCamera.position.z = 20;

            miniMapCamera = new THREE.OrthographicCamera(-60,60,60,-60,0,100);
            miniMapCamera.up.set(0,0,-1);
            miniMapCamera.position.y = 90;
            miniMapCamera.lookAt(new THREE.Vector3());


            var lineGeo = new THREE.Geometry();
            lineGeo.vertices.push(new THREE.Vector3(-10, -10, 0),
                new THREE.Vector3(10, -10, 0),
                new THREE.Vector3(10, 10, 0),
                new THREE.Vector3(-10, 10, 0),
                new THREE.Vector3(-10, -10, 0));
            var line = new THREE.Line(lineGeo,new THREE.LineBasicMaterial({color: 0}));
            miniMapBorder.add(line);
        }

        function buildTire() {
            var tireTexture = loader.load('https://i.imgur.com/jPX4y1n.png?1');    //輪胎
            var tireSideTexture = loader.load('https://i.imgur.com/21rKfjX.jpg?2'); //胎痕
            tireSideTexture.wrapS = THREE.RepeatWrapping;
            tireSideTexture.repeat.set(6,1);

            var allBody = new THREE.Object3D();
            var tire = new THREE.Mesh(new THREE.CircleGeometry(5,64),new THREE.MeshPhongMaterial({map: tireTexture, transparent: true, side: THREE.DoubleSide}));
            var tire2 = new THREE.Mesh(new THREE.CircleGeometry(5,64),new THREE.MeshPhongMaterial({map: tireTexture, transparent: true, side: THREE.DoubleSide}));
            var tireSide = new THREE.Mesh(new THREE.CylinderGeometry(5,5,4,64,1,true),new THREE.MeshPhongMaterial({map: tireSideTexture, side: THREE.DoubleSide}));

            tire.customDepthMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    texture: {
                        type: 't',
                        value: tireTexture
                    }
                },
                vertexShader: document.getElementById('vertexShaderDepth').textContent,
                fragmentShader: document.getElementById('fragmentShaderDepth').textContent
            });

            tire2.customDepthMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    texture: {
                        type: 't',
                        value: tireTexture
                    }
                },
                vertexShader: document.getElementById('vertexShaderDepth').textContent,
                fragmentShader: document.getElementById('fragmentShaderDepth').textContent
            });

            tire.position.set(0,0,2);
            tire2.position.set(0,0,-2);
            tireSide.rotation.x = Math.PI / 2;
            allBody.add(tire,tire2,tireSide);

            allBody.traverse(mesh =>{
                    if(mesh instanceof THREE.Mesh){
                        mesh.castShadow = true;
                    }
                }
            );
            return allBody;
        }

        function init() {
            scene = new THREE.Scene();
            clock = new THREE.Clock();
            stats = new Stats();
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.top = '0px';

            stats.domElement.style.zIndex = 100;
            document.body.appendChild(stats.domElement);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 4000);
            camera.position.set(-50,20,0);
            camera.lookAt(new THREE.Vector3());
            scene.add(camera);

            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor('#7cddfd');
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFShadowMap;
            renderer.autoClear = false;


            light = new THREE.DirectionalLight(0x666666);
            light.shadow.camera.top = -100;
            light.shadow.camera.left = -100;
            light.shadow.camera.bottom = 100;
            light.shadow.camera.right = 100;
            light.castShadow = true;
            light.shadow.mapSize.width = light.shadow.mapSize.height = 1024;

            light.shadow.camera.near = 5;
            light.shadow.camera.far = 4000;
            light.shadow.camera.fov = light.angle / Math.PI * 180;

            scene.add(light);

            document.body.appendChild(renderer.domElement);

            loader = new THREE.TextureLoader();
            loader.crossOrigin = '';

            //--------------------------基本初始化完畢----------------------------//

            var plane = new THREE.Mesh(new THREE.PlaneGeometry(20000,20000),new THREE.MeshPhongMaterial());
            plane.rotation.x = -Math.PI / 2;
            plane.receiveShadow = true;

            scene.add(plane);

            car = new Car();
            car.body.add(camera);
            light.target = car.body;

            for(var i = 0;i < 100;i++){
                var test = new THREE.Mesh(new THREE.SphereGeometry(5),new THREE.MeshNormalMaterial());
                test.position.set(Math.random() * 1000,Math.random() * 50 + 20,Math.random() * 1000);
                scene.add(test);
            }

            //----------------------------遊戲場景初始化完畢---------------------------//

            dashboard = new THREE.Scene();
            var x = window.innerWidth / window.innerHeight;
            dashboardCamera = new THREE.OrthographicCamera(-10 * x, 10 * x, 10, -10, -10, 1600);

            for(var i = 0; i<= 180; i += 10){
                text = new THREE_Text.MeshText2D(String(i),{align: THREE_Text.textAlign.center, font: "100px Arial", fillStyle: "#ffffff"});
                text.position.copy(new THREE.Vector3(-5,0,0).applyAxisAngle(new THREE.Vector3(0,0,-1),Math.PI / 180 * i).add(new THREE.Vector3(0,-9,0)));
                text.scale.set(0.005,0.005,0.005);
                dashboard.add(text);
            }

            backAlert = new THREE_Text.MeshText2D('R',{align: THREE_Text.textAlign.center, font: "100px Arial", fillStyle: "#ff0000"});
            backAlert.scale.set(0.02,0.02,0.02);
            backAlert.position.set(0,-6,0);
            backAlert.visible = false;

            compass = buildCompass();
            compass.position.set(x * 10 * 4 / 5, 10 * 75 / 100, 0);

            speedLine = buildLine();
            speedLine.position.y = -9.3;

            dashboardCamera.position.set(0,0,100);
            dashboard.add(speedLine,compass,backAlert);

            buildMiniMap();
            car.body.add(miniMapCamera);
        }

        function animate() {
            stats.update();

            lightAngle += 0.01;
            light.position.copy(new THREE.Vector3(100,0,0).applyAxisAngle(new THREE.Vector3(0,0,1),lightAngle));
            light.position.x += car.body.position.x;
            light.position.z = car.body.position.z;

            compass.rotation.z = -car.angle;
            if(car.speed < 0.0){
                backAlert.visible = true;
                speedLine.rotation.z = (car.speed / 180 * Math.PI);
            }
            else {
                backAlert.visible = false;
                speedLine.rotation.z = -(car.speed / 180 * Math.PI);
            }

            var dt = clock.getDelta();
            car.update(dt);

            requestAnimationFrame(animate);
            render();
        }

        function render() {
            var ww = window.innerWidth;
            var hh = window.innerHeight;

            renderer.clear();
            renderer.setScissorTest(true);
            renderer.setViewport(0,0,ww,hh);
            renderer.setScissor(0,0,ww,hh);

            renderer.render(scene,camera);
            renderer.render(dashboard,dashboardCamera);

            renderer.setViewport(ww * 0.77,hh * 0.70, ww * 0.23, hh * 0.30);
            renderer.setScissor(ww * 0.77,hh * 0.70, ww * 0.23, hh * 0.30);
            renderer.clear();
            renderer.render(miniMapBorder,miniMapBorderCamera);
            renderer.render(scene,miniMapCamera);

            renderer.setScissorTest(false);
        }

    </script>
</body>
</html>